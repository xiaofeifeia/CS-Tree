面经来源：[牛客网](https://www.nowcoder.com/discuss/224078?type=2&order=0&pos=1&page=1)

1.谈一谈高并发，说一下ReentrantLock的应用场景，什么时候用CAS，你是如何使用高并发的 ，说一下volatile，应用场景是什么

**高并发**

随着用户量的增加，一个系统有可能会产生高并发的问题。高并发简单的来说就是在同一时刻很多用户访问同一资源的问题，专业一点的说法就是在同一时刻有很多个线程访问了同一个数据资源。

**ReentrantLock应用场景**

1.  需要进行互斥访问的代码块中。
2.  读多写少的场景可以使用ReentrantLock的读写锁。
3.  等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，相对于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。
4.  公平锁，同步队列队首出队保证公平。
5.  一把锁可以绑定多个条件，一个ReentrantLock对象可以同时绑定多个Condition。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

**什么时候使用CAS**

1.  当要修改的变量是volatile修饰的属性是

2.  最好不是CPU密集型任务时
3.  读多写少

**volatile**

volatile修饰的变量，访问它的时候需要从主内存获取，对它的修改必须同步刷新至主内存，保证了对所有线程的可见性。

会在对volatile修饰的变量前后插入内存屏障，禁止指令重排序。例如对普通变量的初始化操作，原本应该是先分配内存，然后初始化对象，再将引用指向该内存。但是在cpu优化下，可能会被重排序为先分配内存，然后将引用指向该内存，再初始化对象。而有了volatile修饰后，该重排序会被禁止，可用于双重检测单例模式。

2.数据库的事务，四个隔离级别，可重复读为什么会产生幻读，怎么解决

**事务** 就是保证一个或多个对数据库的操作具有**原子性、隔离性、一致性、持久性**的。

**四个隔离级别：**

**读未提交：** 最低级别的隔离，能够读到其他事务还未提交的脏数据。

**读已提交：** 只能读到其他事务提交后的数据，事务1先读到`A`为`a`，这时候事务2修改`A`为`b`并提交了事务，事务1再读`A`发现变成了`b`，导致一个事务中不可重复读数据。

**可重复读：** 事务1中对同一数据的两次读取，结果始终相同。但是可能会有**幻读**产生，即同一个查询读到之前未读到的数据。在`Mysql`中利用`MVCC`解决了`快照读幻读`，利用`间隙锁`解决了`当前读幻读`。

**串行化：** 最高的隔离级别，所有事物都必须串行，效率很低，不要使用。

**可重复度为什么会产生幻读？**

事务1执行的时候，执行了一条范围查询语句，读出来数据为A。之后事务2向这个范围内插入了一条数据，事务1再执行之前的SQL，发现多出来一条数据，于是产生了幻读。

**怎么解决幻读？**

在`Innodb`引擎中，每条聚集索引都会有两个隐藏字段：`trx_id`和`roll_pointer`，每次事务对一条记录进行改动时，就会将`事务id`赋值给`trx_id`，并且会将旧数据写入一条undo日志，每条undo日志也都有一个roll_pointer属性，可以将这些undo日志都连起来，串成一个链表，undo日志的写入采用头插法，新数据在前。

1.  **快照读：** `MVCC`中有一个`ReadView`的概念，其中记录了生成`ReadView`时的`活跃事务id列表:m_ids`、`最小事务id:min_trx_id`、`将要分配给下一个事务的id:max_trx_id`、`生成ReadView的事务id:creator_trx_id`。如果被访问版本的`trx_id`与`creator_trx_id`相同或者小于`min_trx_id`，则可以访问；如果被访问版本的`trx_id`大于等于`max_trx_id`，则不能访问；如果被访问版本的`trx_id`在`min_trx_id`和`max_trx_id`之间，则当`trx_id`不在`m_ids`中时才能访问。
2.  **当前读：** `InnoDB`存储引擎有三种锁：`Record lock`：单个行记录上的锁；`Gap lock`：间隙锁，锁定一个范围，不包括记录本身；`Next-key lock`：`record+gap` 锁定一个范围，包含记录本身。`innodb`对于行的查询使用`next-key lock`，当查询的索引含有唯一属性时，将`next-key lock`降级为`record key`。

3.数据库的索引，说一说B+树与B树的区别，mysql为什么要用B+树，能不能用红黑树？

**索引：** 索引是用来加快查寻的，`Innodb`中索引采用`B+`树来实现。

**为什么采用B+树**

1.  它是一颗平衡树，并且每一个节点都有很多子节点，使得树很矮，一般在4以内，使得查询效率很高。
2.  B+树的叶子节点按顺序连接成了一个双向链表，使得范围查询效率很高，只用遍历链表即可。
3.  一个节点的大小等于一个页，这样每个节点只需要一次I/O就可以完全载入。

**为什么不用红黑树**

1.  红黑树范围查询效率比B+树低很多。
2.  红黑树高度比B+树高很多。

4.说一下索引优化，如何确认这个索引合不合适

**查询优化：**

1.  使用索引最左匹配原则，选择性大的列放前面。
2.  聚集函数字段加索引。
3.  查询满足后，使用limit提前终止。
4.  `like`左边不要使用`%`，会导致索引失效。
5.  where查询时，索引列不要做运算或函数的参数。
6.  尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描。
7.  避免在WHERE子句中使用 != 或 <>操作符，否则将引擎放弃使用索引而进行全表扫描。
8.  查询尽量使用覆盖索引，减少回表。
9.  使用 JOIN 级联查询时，应该保证两表中 JOIN 的字段已建立过索引且类型相同。
10.  尽可能的使用 NOT NULL：NULL会占用额外的空间来记录其值是否为空。
11.  IP地址 存成 `INT UNSIGNED`。
12.  拆分大的 DELETE 或 INSERT 语句，避免长时间锁表。
13.  不用外键，不用UNIQUE，由程序保证约束。
14.  使用OR时，前后条件都必须是索引，否则索引失效。
15.  OR改写成IN : OR的效率是n级别，IN的效率是 log(n)级别。
16.  尽量使用 count(\*)计算数量 : 列的偏移 量决定性能，列越靠后，访问的开销越大。由于 count(\*)的算法与列偏移量无关，所以 count(*) 最快，count(最后列)最慢

5.说一下Spring的AOP实现原理，他的应用场景，还有没有其他框架用到AOP?

**原理：** Spring AOP是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理。

**应用场景：** AOP能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

6.你都知道哪些设计模式，说一说工厂模式，应用场景，你的项目中有没有用到，怎么用的

**单例模式：** 确保某一个类只有一个实例，而且自行实例化并且向整个系统提供这个实例。 **spring默认对bean的管理方式。** **使用场景：** 要求生成唯一序列号的环境；页面上的访问计数器；创建一个对象需要消耗过多资源：IO、数据库等。

**简单工厂：** 提供一个创建对象实例的功能，而无须关心其具体实现。**场景：** 工厂类负责创建的对象较少，客户端只关心传入工厂类的参数，不关心创建对象的逻辑。 **Spring IOC容器中，BeanFactory和ApplicationContext就是工厂类，负责管理所有的Bean实例。**

**工厂方法：** 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到了子类 。 **JDK中的Iterator类运用了工厂方法模式，每种集合类都负责实例化对应的Iterator实例。**

**抽象工厂：** 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体类型。**场景：** 一个对象族都具有相同的约束，则可以使用抽象工厂模式。

**代理模式：** 为其他对象提供一种代理以控制这个对象的访问。**场景：** spring AOP。

**模板模式：** 定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的节后即可重定义该算法的某些特定步骤。**JDK中的AbstractList类运用了模板方法模式 。Spring中`JDBCTemplate`运用了模板方法模式。**

**装饰器模式：** 动态地给一个对象添加一些额外的职责。相比生成子类更为灵活。 **场景：** 需要扩展一个类的功能。 **JDK的输入输出流。**

**责任链模式：** 使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直至有对象处理它为止。**Servlet的Filter。** 

**观察者模式：** 定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，所有依赖于它的对象都会得到通知并被自动更新。**场景：** 关联行为场景；事件多级触发场景；跨系统的消息交换场景。

**策略模式：** 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。**场景：** 多个类只有算法或者行为上稍有不同的场景。**Comparator.compare()。** 

**构建模式：** 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 **场景：** 相同的方法，不同的执行顺序，产生不同的时间结果时；多个零件或部件，都可以装配到一个对象中，但是产生的结果不同；产品类非常复杂时。**JDK中的StringBuilder。** 

**原型模式：** 使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。**场景：** 资源优化场景；性能和安全性要求较高的场景；一个对象多个修改者。



7.接口和抽象类的区别，为什么要有抽象类？

1.  从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
2.  从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
3.  接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
4.  接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

8.equals与hashCode的区别？

hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。

9.什么时候用加了锁的HashMap，什么时候用currentHashMap？

在多线程并发场景下使用加锁的HashMap开销很大，简易使用currentHashMap。HashMap在没有竞争的环境下使用，效率较高。

10.currentHashMap的实现？

**jdk1.8之前：** 采用分段锁来实现。将整个currentHashMap分成了若干分段（Segment，继承自ReentrantLock，默认16段），每一个分段都是一个HashMap，用一个数组来保存分段。当需要对某一个键值对进行加锁时，只需要对该键值对所在的分段加锁即可，多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高。

**jdk1.8及之后：** 使用了 CAS 操作来支持更高的并发度，只用对键值对所在的位置头结点上锁，在 CAS 操作失败时使用内置锁 synchronized。并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。

11.HashMap如何解决hash冲突？

HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的键值对。当HashMap的元素个数到达64个时，链表长度到达8时将会树化。

12.你了解那些排序算法，他们的时间复杂度和空间复杂度是多少？

**不稳定：** 快排（O(n * logn)，O(logn)）、希尔排序（O(n ^ 1.5)，O(1)）、堆排序（O(n * logn)，O(1)）、选择排序（O(n ^ 2)，O(1)）。

**稳定：** 归并排序（O(n * logn)，O(n)）、冒泡排序（O(n ^ 2)，O(1)）、插入排序（O(n ^ 2)，O(1)）。

13.说一下GC的过程，收集算法，垃圾收集器

**GC过程：** 

使用可达性算法，标记`GC Roots`不能到达的对象，然后将其回收。

当新生代空间不足时，会触发`minor gc`，回收新生代垃圾。当老年代空间不足时，触发`full gc`，回收所有堆内存区域的垃圾。

14.如何查看垃圾收集的状态？

使用`jstat -gutil`命令查看各区域的gc情况。

15.说一下JVM的内存分布，如何调整新生代和老年代的比例？

JVM内存分为线程共享部分和线程私有部分。

**线程共享：** 方法区、堆、元空间、直接内存。

**线程私有：** 虚拟机栈、本地方法栈、pc计数器。

**调整命令：** `-XX:NewRatio`

16.Linux的软连接与硬链接

**硬连接：** 不会建立inode，只是在文件的`inode link count`域加1。

**软连接：** 新建一个文件，指向别的文件。